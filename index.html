<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8">
<title>Geo Nuclear Quick Pick 4.8.1</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
<style>
body {
  font-family: system-ui;
  background: #0f1220;
  margin: 0;
  padding: 20px;
  color: #ffffff;
}
h2 {text-align:center; margin-bottom:10px; color:#00ffea;}
#preview, #matches {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 12px;
  margin-top: 20px;
}
.match {
  padding: 12px;
  border-radius: 10px;
  font-size: 14px;
  color: #ffffff;
  transition: transform 0.2s;
}
.match h3 { font-size: 20px; margin:0 0 5px 0; }
.match p { margin:2px 0; font-size:12px; color:#ffffffcc; }
.top3 {
  font-size: 22px;
  border: 2px solid #00ffea;
  box-shadow: 0 0 20px #00ffea;
  transform: scale(1.05);
}
input, button { padding:10px; margin:5px; font-size:16px; }
</style>
</head>
<body>

<h2>ðŸ’¥ Geo Nuclear Quick Pick 4.8.1 ðŸ’¥</h2>
<input type="file" id="imgInput" accept="image/*">
<button onclick="runOCR()">RuleazÄƒ analizÄƒ</button>

<h3>Preview OCR</h3>
<div id="preview"></div>

<h3>Meciuri Profitabile</h3>
<div id="matches"></div>

<script>
// Lista echipelor pentru fuzzy matching
const validTeams = [
  "Arsenal","Aston Villa","Brighton","Burnley","Chelsea","Crystal Palace",
  "Everton","Fulham","Liverpool","Luton","Man City","Man Utd","Newcastle",
  "Nottingham","Sheffield","Southampton","Tottenham","West Ham","Wolves"
];

// Fuzzy matching echipe
function findTeam(name){
  name = name.toLowerCase().replace(/[^a-z ]/g,'').trim();
  for(let t of validTeams){
    if(t.toLowerCase().includes(name) || name.includes(t.toLowerCase())) return t;
  }
  return name; // fallback: return text curat
}

// Monte Carlo
function poissonRandom(lambda){let L=Math.exp(-lambda),p=1,k=0;while(p>L){k++;p*=Math.random();}return k-1;}
function monteCarlo(xgH,xgA,sims=100000){
  let cH=0,cX=0,cA=0;
  for(let i=0;i<sims;i++){
    let h=poissonRandom(xgH), a=poissonRandom(xgA);
    if(h>a)cH++; else if(h==a)cX++; else cA++;
  }
  return {pH:cH/sims, pX:cX/sims, pA:cA/sims};
}

// OCR
function runOCR(){
  let file=document.getElementById("imgInput").files[0];
  if(!file){alert("Alege poza"); return;}
  document.getElementById("preview").innerHTML = "Se proceseazÄƒ OCR...";
  document.getElementById("matches").innerHTML = "";
  Tesseract.recognize(file,'eng',{logger:m=>console.log(m)})
    .then(({data:{text}})=>{processText(text);});
}

// Curatare OCR
function cleanText(text){
  return text.replace(/\r|\n|\t/g,' ')
             .replace(/Meci|Egal/gi,'')
             .replace(/[^\w\s\.\-xG\/]/gi,' ')
             .replace(/\s+/g,' ')
             .trim();
}

// Determinare culoare dupa edge
function getColor(edge){
  if(edge>=1.0) return '#00ffea';
  if(edge>=0.5) return '#ffff33';
  return '#ff4500';
}

// Parse È™i afiÈ™are
function processText(rawText){
  let text = cleanText(rawText);
  const matchRegex = /([A-Za-z\s]+)\s*-\s*([A-Za-z\s]+)\s*([\d\.]+)\/([\d\.]+)\/([\d\.]+)(.*?(\d*\.?\d+)xG.*?(\d*\.?\d+)xG)?/gi;
  let previewDiv = document.getElementById("preview");
  let matchesDiv = document.getElementById("matches");
  previewDiv.innerHTML = "";
  matchesDiv.innerHTML = "";
  let matchesFound = [];
  let results = [];
  let m;

  // Preview OCR È™i fallback numeric
  while((m = matchRegex.exec(text)) !== null){
    let t1 = findTeam(m[1]);
    let t2 = findTeam(m[2]);
    let odd1 = parseFloat(m[3]) || 1.5;
    let oddX = parseFloat(m[4]) || 3.5;
    let odd2 = parseFloat(m[5]) || 2.5;
    let xgH = m[7]?parseFloat(m[7]):1.5;
    let xgA = m[8]?parseFloat(m[8]):1.5;

    // Preview
    let divPrev = document.createElement("div");
    divPrev.className="match";
    divPrev.style.background="#333";
    divPrev.innerHTML=`<h3>${t1} vs ${t2}</h3>
                       <p>Cote: ${odd1}/${oddX}/${odd2}</p>
                       <p>xG: ${xgH}-${xgA}</p>`;
    previewDiv.appendChild(divPrev);

    let key = t1+"|"+t2;
    if(matchesFound.includes(key)) continue;
    matchesFound.push(key);

    // Calcul Edge
    let sim = monteCarlo(xgH,xgA);
    let maxP = Math.max(sim.pH, sim.pX, sim.pA);
    let edge = 0;
    if(maxP==sim.pH) edge = sim.pH*odd1-1;
    else if(maxP==sim.pX) edge = sim.pX*oddX-1;
    else edge = sim.pA*odd2-1;

    if(edge>0){
      let pick = maxP==sim.pH?t1:maxP==sim.pX?"Egal":t2;
      results.push({pick, t1, t2, odd1, oddX, odd2, xgH, xgA, edge});
    }
  }

  if(results.length==0){
    matchesDiv.innerHTML = "Nu sunt meciuri profitabile";
    return;
  }

  // Sortare descrescÄƒtor dupÄƒ edge
  results.sort((a,b)=>b.edge - a.edge);

  results.forEach((r,index)=>{
    let div = document.createElement("div");
    div.className = "match";
    if(index<3) div.classList.add("top3");
    div.style.background = getColor(r.edge);
    div.innerHTML=`<h3>${r.pick}</h3>
                   <p>${r.t1} vs ${r.t2}</p>
                   <p>Cote: ${r.odd1}/${r.oddX}/${r.odd2}</p>
                   <p>xG: ${r.xgH}-${r.xgA}</p>
                   <p>Edge: ${r.edge.toFixed(2)}</p>`;
    matchesDiv.appendChild(div);
  });
}
</script>

</body>
</html>