<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smart Live PRO++</title>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<style>
body{
    font-family: system-ui;
    background:#0f1220;
    color:white;
    text-align:center;
    padding:20px;
}
button{
    padding:12px 20px;
    font-size:16px;
    border:none;
    border-radius:8px;
    background:#2ecc71;
    color:black;
    cursor:pointer;
    margin-top:10px;
}
.result{
    margin-top:20px;
    padding:15px;
    background:#1a1f35;
    border-radius:10px;
}
.match{
    margin-bottom:15px;
    padding:10px;
    background:#23284a;
    border-radius:8px;
}
</style>
</head>
<body>

<h2>Smart Live PRO++ ðŸ§ âš½</h2>

<input type="file" id="imageInput" accept="image/*"><br>
<button onclick="runOCR()">RuleazÄƒ analizÄƒ</button>

<div id="output" class="result"></div>

<script>

async function runOCR(){

    let file = document.getElementById("imageInput").files[0]
    if(!file){
        alert("SelecteazÄƒ o pozÄƒ")
        return
    }

    const worker = await Tesseract.createWorker()

    await worker.loadLanguage('eng')
    await worker.initialize('eng')

    await worker.setParameters({
        tessedit_pageseg_mode: 6
    })

    const { data } = await worker.recognize(file)
    await worker.terminate()

    const lines = rebuildLines(data.words)
    const matches = parseMatches(lines)

    display(matches)
}

function rebuildLines(words){

    let map = {}

    words.forEach(w=>{
        let y = Math.round(w.bbox.y0 / 12) * 12
        if(!map[y]) map[y] = []

        map[y].push({
            text:w.text,
            x:w.bbox.x0
        })
    })

    return Object.keys(map)
        .sort((a,b)=>a-b)
        .map(y=>{
            return map[y]
                .sort((a,b)=>a.x-b.x)
                .map(w=>w.text)
                .join(" ")
                .trim()
        })
        .filter(l=>l.length>2)
}

function parseMatches(lines){

    let matches=[]
    let teamBuffer=[]

    const bannedWords = [
        "meci","egal","1","x","2",
        "p","pj","v","e","i","g","pts"
    ]

    function isTeam(line){

        let lower = line.toLowerCase()

        if(line.match(/\d/)) return false

        for(let word of bannedWords){
            if(lower === word) return false
            if(lower.startsWith(word+" ")) return false
        }

        if(lower.includes("cote")) return false

        return line.length > 3
    }

    for(let i=0;i<lines.length;i++){

        let line = lines[i]

        if(isTeam(line)){
            teamBuffer.push(line)
        }

        let odds = line.match(/(\d+\.\d+)/g)

        if(odds && odds.length>=3){

            if(teamBuffer.length>=2){

                let home = teamBuffer[teamBuffer.length-2]
                let away = teamBuffer[teamBuffer.length-1]

                matches.push({
                    home:clean(home),
                    away:clean(away),
                    odd1:parseFloat(odds[0]),
                    oddX:parseFloat(odds[1]),
                    odd2:parseFloat(odds[2])
                })
            }

            teamBuffer=[]
        }
    }

    return matches
}

function clean(text){
    return text.replace(/[^\w\s\.\-]/g,"").trim()
}

function display(matches){

    const out = document.getElementById("output")
    out.innerHTML = ""

    if(matches.length===0){
        out.innerHTML = "Nu s-au detectat meciuri."
        return
    }

    matches.forEach(m=>{

        let prob1 = 1/m.odd1
        let probX = 1/m.oddX
        let prob2 = 1/m.odd2

        let sum = prob1+probX+prob2

        let p1 = (prob1/sum*100)
        let pX = (probX/sum*100)
        let p2 = (prob2/sum*100)

        let max = Math.max(p1,pX,p2)

        let rec =
            max===p1 ? m.home :
            max===pX ? "Egal" :
            m.away

        out.innerHTML += `
        <div class="match">
            <strong>${m.home} vs ${m.away}</strong><br>
            Cote: ${m.odd1} / ${m.oddX} / ${m.odd2}<br>
            ðŸ”¥ Recomandare Smart: ${rec}<br>
            Scor Ã®ncredere: ${max.toFixed(2)}%
        </div>`
    })
}

</script>
</body>
</html>