<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smart Live PRO+</title>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<style>
body{
    font-family: system-ui;
    background:#0f1220;
    color:white;
    text-align:center;
    padding:20px;
}
button{
    padding:12px 20px;
    font-size:16px;
    border:none;
    border-radius:8px;
    background:#2ecc71;
    color:black;
    cursor:pointer;
    margin-top:10px;
}
.result{
    margin-top:20px;
    padding:15px;
    background:#1a1f35;
    border-radius:10px;
}
.match{
    margin-bottom:15px;
    padding:10px;
    background:#23284a;
    border-radius:8px;
}
</style>
</head>
<body>

<h2>Smart Live PRO+ ðŸ§ âš½</h2>

<input type="file" id="imageInput" accept="image/*"><br>
<button onclick="runOCR()">RuleazÄƒ analizÄƒ</button>

<div id="output" class="result"></div>

<script>

async function runOCR(){

    let file = document.getElementById("imageInput").files[0]
    if(!file){
        alert("SelecteazÄƒ o pozÄƒ")
        return
    }

    const worker = await Tesseract.createWorker()

    await worker.loadLanguage('eng')
    await worker.initialize('eng')

    await worker.setParameters({
        tessedit_pageseg_mode: 6
    })

    const { data } = await worker.recognize(file)
    await worker.terminate()

    const lines = rebuildLines(data.words)
    const matches = parseMatchesProPlus(lines)

    display(matches)
}

function rebuildLines(words){

    let map = {}

    words.forEach(w=>{

        let y = Math.round(w.bbox.y0 / 12) * 12

        if(!map[y]) map[y] = []

        map[y].push({
            text:w.text,
            x:w.bbox.x0
        })
    })

    return Object.keys(map)
        .sort((a,b)=>a-b)
        .map(y=>{
            return map[y]
                .sort((a,b)=>a.x-b.x)
                .map(w=>w.text)
                .join(" ")
                .trim()
        })
        .filter(l=>l.length>2)
}

function parseMatchesProPlus(lines){

    let matches=[]

    for(let i=0;i<lines.length;i++){

        let odds = lines[i].match(/(\d+\.\d+)/g)

        if(odds && odds.length>=3){

            let home = lines[i-2] || ""
            let away = lines[i-1] || ""

            if(validTeam(home) && validTeam(away)){

                matches.push({
                    home:cleanTeam(home),
                    away:cleanTeam(away),
                    odd1:parseFloat(odds[0]),
                    oddX:parseFloat(odds[1]),
                    odd2:parseFloat(odds[2])
                })
            }
        }
    }

    return matches
}

function validTeam(t){
    return t && !t.match(/\d/) && t.length>2
}

function cleanTeam(t){
    return t.replace(/[^\w\s\.]/g,"").trim()
}

function display(matches){

    const out = document.getElementById("output")
    out.innerHTML = ""

    if(matches.length===0){
        out.innerHTML = "Nu s-au detectat meciuri."
        return
    }

    matches.forEach(m=>{

        let prob1 = (1/m.odd1)
        let probX = (1/m.oddX)
        let prob2 = (1/m.odd2)

        let sum = prob1+probX+prob2

        let p1 = (prob1/sum*100).toFixed(2)
        let pX = (probX/sum*100).toFixed(2)
        let p2 = (prob2/sum*100).toFixed(2)

        let max = Math.max(p1,pX,p2)
        let rec = max==p1?m.home:max==pX?"Egal":m.away

        out.innerHTML += `
        <div class="match">
            <strong>${m.home} vs ${m.away}</strong><br>
            Cote: ${m.odd1} / ${m.oddX} / ${m.odd2}<br>
            ðŸ”¥ Recomandare Smart: ${rec}<br>
            Scor Ã®ncredere: ${max}%
        </div>`
    })
}

</script>
</body>
</html>