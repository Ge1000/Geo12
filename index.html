<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8">
<title>Geo OCR + xG Analyzer Final</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
<style>
body{font-family:system-ui;background:#0f1220;color:white;padding:20px}
input,button{padding:8px;margin:5px}
.box{background:#1a1f38;padding:15px;margin-top:20px;border-radius:10px}
.good{color:#00ff9d}
.bad{color:#ff4d4d}
h3{margin-top:15px}
</style>
</head>
<body>

<h2>ðŸ“¸ Geo OCR + xG Analyzer Final</h2>

<p>ÃŽncarcÄƒ poza cu meciuri È™i cote (xG optional, rezultat optional 1/X/2):</p>
<input type="file" id="imgInput" accept="image/*">
<button onclick="runOCR()">RuleazÄƒ AnalizÄƒ</button>

<div class="box" id="result">Rezultatele vor apÄƒrea aici...</div>

<script>
// --- FuncÈ›ii matematice ---
function poissonRandom(lambda){let L=Math.exp(-lambda),p=1,k=0;while(p>L){k++;p*=Math.random();}return k-1;}
function monteCarlo(xgH,xgA,sims=100000){let c1=0,cX=0,c2=0;for(let i=0;i<sims;i++){let h=poissonRandom(xgH),a=poissonRandom(xgA);if(h>a)c1++;else if(h==a)cX++;else c2++;}return [c1/sims,cX/sims,c2/sims];}

// --- OCR + procesare text ---
function runOCR(){
  let file=document.getElementById("imgInput").files[0];
  if(!file){alert("Alege poza"); return;}
  result.innerHTML="Se proceseazÄƒ OCR...â³";

  Tesseract.recognize(file,'eng',{logger:m=>console.log(m)})
    .then(({data:{text}})=>{
      processText(text);
    });
}

function processText(text){
  // CurÄƒÈ›are text OCR
  text=text.replace(/\r/g,'\n').replace(/\t/g,' ').replace(/\s+/g,' ').trim();
  let lines=text.split("\n").map(l=>l.trim()).filter(l=>l.length>0);
  let output="";

  for(let l of lines){
    // Flexibil: echipe cu spaÈ›ii, cote cu punct sau virgulÄƒ, xG optional, rezultat optional
    // Caut cote: orice numÄƒr cu 1-2 zecimale
    let numbers=l.match(/[\d]+\.[\d]+/g);
    if(!numbers || numbers.length<2) continue; // trebuie minim 2 cote

    // Extragem echipe: partea text Ã®ntre Ã®nceput È™i prima cotÄƒ, È™i Ã®ntre cote
    let parts=l.split(numbers[0]);
    if(parts.length<2) continue;
    let teamA=parts[0].trim();
    let rest=parts[1];
    let odd1=parseFloat(numbers[0]);
    let oddX=parseFloat(numbers[1]);
    let odd2=numbers.length>=3?parseFloat(numbers[2]):null;

    let teamB="";
    let xgH=1.5, xgA=1.5;
    let resultReal="";

    // CÄƒutare xG È™i echipÄƒ B
    let xgMatch=l.match(/(\d*\.?\d+)xG/gi);
    if(xgMatch && xgMatch.length>=1) xgH=parseFloat(xgMatch[0]);
    if(xgMatch && xgMatch.length>=2) xgA=parseFloat(xgMatch[1]);

    // Extragem echipa B: text dupÄƒ ultima cotÄƒ pÃ¢nÄƒ la xG sau rezultat
    let lastNumberIndex=l.lastIndexOf(numbers[ numbers.length>=3?2:1 ]);
    teamB=l.substring(lastNumberIndex+numbers[ numbers.length>=3?2:1 ].length).replace(/xG/gi,'').replace(/[1X2]/i,'').trim();

    // Detect rezultat 1/X/2
    let resultMatch=l.match(/[1X2]/i);
    if(resultMatch) resultReal=resultMatch[0].toUpperCase();

    if(!odd2) odd2=odd1; // fallback dacÄƒ nu existÄƒ a treia cotÄƒ

    // Monte Carlo
    let probs=monteCarlo(xgH,xgA);
    let edge=[probs[0]-1/odd1,probs[1]-1/oddX,probs[2]-1/odd2];
    let bestIndex=edge.indexOf(Math.max(...edge));
    let pick=["1","X","2"][bestIndex];

    let cls=edge[bestIndex]>0.04?"good":"bad"; // edge>4% = value bet
    output+=`<p class="${cls}">
      ${teamA} vs ${teamB} | Pick: ${pick} | Prob: ${(probs[bestIndex]*100).toFixed(2)}% | Edge: ${(edge[bestIndex]*100).toFixed(2)}%` + (resultReal?` | Rezultat real: ${resultReal}`:'') + `
    </p>`;
  }

  result.innerHTML=output||"Nu s-au gÄƒsit meciuri valide Ã®n pozÄƒ.";
}
</script>

</body>
</html>