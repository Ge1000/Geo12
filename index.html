<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8">
<title>OMNISCAN â€“ Meme Coins Ultra Mega Quantum (15m)</title>
<script src="https://cdn.onesignal.com/sdks/OneSignalSDK.js" async></script>
<style>
body { background:#000; color:#0f0; font-family:monospace; padding:10px; }
h1 { color:#0ff; }
.signal { margin-bottom:15px; border-bottom:1px solid #0f0; padding-bottom:5px; }
.address { background:#111; padding:2px 4px; font-family:monospace; display:inline-block; }
</style>
</head>
<body>

<h1>OMNISCAN â€“ Meme Coins Ultra Mega Quantum (15m) â‰¥60%</h1>
<div id="output">Motor cosmic quantum se iniÈ›ializeazÄƒ...</div>

<script>
// --- INIT OneSignal ---
window.OneSignal = window.OneSignal || [];
OneSignal.push(function() {
  OneSignal.init({
    appId: "YOUR_REAL_ONESIGNAL_APP_ID",
    notifyButton: { enable:false }
  });
});

// --- FUNCTII QUANTUM ---
function quantumTrendScore(prices){
    let score=0;
    if(prices.length>=5){
        for(let i=prices.length-5;i<prices.length-1;i++){
            const diff=prices[i+1]-prices[i];
            score += diff>0 ? 10 + Math.log(1+diff*100) : 0;
        }
    }
    return Math.min(score,40);
}

function quantumVolumeScore(currentVolume, avgVolume){
    return currentVolume>avgVolume*1.2 ? 30 : 0;
}

function quantumLiquidityScore(liquidity){
    return liquidity>5000 ? 30 : 0;
}

// --- BINANCE MEME NOU AUTOMAT ---
async function fetchBinanceNewMemeSymbols(){
    try {
        const res = await fetch('https://api.binance.com/api/v3/exchangeInfo');
        const data = await res.json();
        const memeKeywords = ["DOGE","SHIB","CAKE","PEPE","SAITAMA","ELON"];
        const newMemeSymbols = data.symbols
            .filter(s => s.quoteAsset === "USDT" && memeKeywords.some(k=>s.baseAsset.includes(k)))
            .map(s => ({symbol:s.symbol, address:s.baseAsset}));
        return newMemeSymbols;
    } catch(e) { console.error(e); return []; }
}

async function analyzeBinanceMeme(symbolObj){
    const symbol = symbolObj.symbol;
    const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=15m&limit=15`;
    const res = await fetch(url);
    const data = await res.json();
    const closes = data.map(c=>parseFloat(c[4]));
    const volumes = data.map(c=>parseFloat(c[5]));
    const avgVolume = volumes.slice(0,-1).reduce((a,b)=>a+b)/(volumes.length-1);
    const currentVolume = volumes[volumes.length-1];
    const currentPrice = closes[closes.length-1];

    // Calcule aproximative MCap (dacÄƒ existÄƒ circulating supply, aici punem doar exemplu placeholder)
    const circulatingSupply = 1000000000; // placeholder, poÈ›i integra API real pentru supply
    const mcap = (currentPrice * circulatingSupply).toLocaleString('en-US', {style:'currency',currency:'USD'});

    const score = quantumTrendScore(closes) + quantumVolumeScore(currentVolume, avgVolume) + quantumLiquidityScore(avgVolume*1000);
    return {symbol, score:Math.min(100,score), price:currentPrice, address:symbolObj.address, mcap};
}

// --- SOLANA MEME NOU ---
async function fetchSolanaNewTokens(){
    try{
        const res = await fetch('https://api.dexscreener.com/latest/dex/tokens?chain=solana');
        const data = await res.json();
        return data.pairs.filter(t=>t.baseToken.dayData.volumeUsd>1000 && parseFloat(t.liquidity)>5000)
                         .slice(0,50)
                         .map(t=>({
                             name:t.baseToken.name,
                             symbol:t.baseToken.symbol,
                             price:parseFloat(t.priceUsd),
                             prices15m:t.baseToken.priceData15m || [],
                             volume:parseFloat(t.baseToken.dayData.volumeUsd),
                             liquidity:parseFloat(t.liquidity),
                             address:t.baseToken.address,
                             mcap:t.baseToken.marketCapUsd ? parseFloat(t.baseToken.marketCapUsd).toLocaleString('en-US', {style:'currency',currency:'USD'}) : "N/A"
                         }));
    }catch(e){console.error(e); return [];}
}

function analyzeSolanaToken(token){
    const score = quantumTrendScore(token.prices15m) + quantumVolumeScore(token.volume, 1000) + quantumLiquidityScore(token.liquidity);
    return {...token, score:Math.min(100,score)};
}

// --- MOTOR QUANTUM ---
async function runQuantumScanner(){
    const output=document.getElementById("output");
    let signals=[];

    // Binance meme automat
    const binanceNewMemeSymbols = await fetchBinanceNewMemeSymbols();
    for(const s of binanceNewMemeSymbols){
        try{
            const res = await analyzeBinanceMeme(s);
            if(res.score>=60) signals.push(res);
        }catch(e){console.error(e);}
    }

    // Solana meme
    const solTokens = await fetchSolanaNewTokens();
    solTokens.forEach(t=>{
        const analyzed = analyzeSolanaToken(t);
        if(analyzed.score>=60) signals.push(analyzed);
    });

    if(signals.length===0){
        output.innerHTML="âš ï¸ Nicio oportunitate meme nouÄƒ â‰¥60% momentan.";
    }else{
        output.innerHTML=signals.map(s=>{
            OneSignal.push(function(){
                OneSignal.sendSelfNotification(
                    `ðŸŒ  Quantum Meme Signal: ${s.symbol}`,
                    `Score: ${Math.round(s.score)}% | Price: ${s.price} | MCap: ${s.mcap} | Address: ${s.address}`,
                    'https://i.imgur.com/U4tV8aQ.png',
                    {url: window.location.href}
                );
            });
            return `<div class="signal">
ðŸš€ ${s.symbol} | Score: ${Math.round(s.score)}% | Price: ${s.price} | MCap: ${s.mcap} | Address: <span class="address">${s.address}</span>
</div>`;
        }).join("");
    }
}

// --- RUN AUTOMATIC LA 1 MIN ---
runQuantumScanner();
setInterval(runQuantumScanner,60000);

</script>
</body>
</html>